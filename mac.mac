;MACRO 1
;no recibe parametros
;es para terminar un programa x86_64
%macro exit 0
        mov rax, 60
        mov rdi, 0
        syscall
%endmacro


;MACRO 2
;no recibe parametros
;imprime el string que esta en rax antes de su llamado
;no importa el tamano del string mientras el ultimo caracter sea '0'
%macro printstring 0
%%_printstring:
        push rax
        mov rbx, 0

%%_printloop:
        inc rax
        inc rbx
        mov cl, [rax]
        cmp cl, 0
        jne %%_printloop

        mov rax, 1
        mov rdi, 1
        pop rsi
        mov rdx, rbx
        syscall
%endmacro


;MACRO 3
;recibe 2 parametros, el primero de 16 reserved bytes y el segundo de 8 reserved bytes
;imprime un numero entero de cualquier tamano
;Modificado a partir de: https://pastebin.com/PN2jKVae
%macro printnum 2
%%_printnum:
        mov rcx, %1
        mov rbx, 10
        mov [rcx], rbx
        inc rcx
        mov [%2], rcx

%%_printnumloop:
        mov rdx, 0
        mov rbx, 10
        div rbx
        push rax
        add rdx, 48

        mov rcx, [%2]
        mov [rcx], dl
        inc rcx
        mov [%2], rcx

        pop rax
        cmp rax, 0
        jne %%_printnumloop

%%_printnumloop2:
        mov rcx, [%2]

        mov rax, 1
        mov rdi, 1
        mov rsi, rcx
        mov rdx, 1
        syscall

        mov rcx, [%2]
        dec rcx
        mov [%2], rcx

        cmp rcx, %1
        jge %%_printnumloop2
%endmacro


;MACRO 4
;al llamar este macro se guarda en eax la cantidad de nucleos del procesador
%macro cantnuc 0
        mov eax, 0xb
        mov ecx, 1
        cpuid
        mov r10d, ebx
        and ebx, 0x0000ffff
%endmacro


;MACRO 5
; Simon Whitehead, 2015
;This program converts numbers into ASCII characters and
;prints them to stdout.
;Imprimir enteros de cualquier tamano sin enter al final
;Modificado para ser utilizado como macro
;Dependencia funci√≥n divloop
%macro printInt 2
        mov rdi,%1	; Move the number to print into rax

        ;itoa
        push rbp
        mov rbp,rsp
        sub rsp,4		; allocate 4 bytes for our local string length counter

        mov rax,rdi		; Move the passed in argument to rax
        lea rdi,[%2+10]	; load the end address of the buffer (past the very end)
        mov rcx,10		; divisor
        mov [rbp-4],dword 0	; rbp-4 will contain 4 bytes representing the length of the string - start at zero

        call divloop
        leave

        ; Write the string returned in rax out to stdout
        mov rdi,rax		; The string pointer is returned in rax - move it to rdi for the function call
        mov rsi,rcx

        ;print  Args: (rdi: char*, rsi: int)
        mov rax,4
        mov rbx,1
        mov rcx,rdi
        mov rdx,rsi

        int 0x80

        ; Write the newline character to stdout
        mov rdi,10
        mov rsi,1

        ;print  Args: (rdi: char*, rsi: int)
        mov rax,4
        mov rbx,1
        mov rcx,rdi
        mov rdx,rsi

        int 0x80
%endmacro


;MACRO 6
;Lee un mensaje del teclado y se almacena en la variable que se pasa como parametro
;Recibe 2 parametros de entrada: primero la direccion de memoria donde se guarda el texto
;y segundo es la cantidad de bytes a guardar
%macro read 2
      	mov rax,0	       ;sys_read
      	mov rdi,0	       ;std_input
      	mov rsi,%1	     ;primer parametro: Variable
      	mov rdx,%2	     ;segundo parametro: Tamano
      	syscall
%endmacro


;Loop necesario para utilizar el macro printInt (MACRO 5)
        ; Loop de division necesario para el macro printInt
        divloop:
        xor rdx,rdx		; Zero out rdx (where our remainder goes after idiv)
        idiv rcx		; divide rax (the number) by 10 (the remainder is placed in rdx)
        add rdx,0x30	; add 0x30 to the remainder so we get the correct ASCII value
        dec rdi		; move the pointer backwards in the buffer
        mov byte [rdi],dl	; move the character into the buffer
        inc dword [rbp-4]	; increase the length

        cmp rax,0		; was the result zero?
        jnz divloop	; no it wasn't, keep looping

        mov rax,rdi		; rdi now points to the beginning of the string - move it into rax
        mov rcx,[rbp-4]	; rbp-4 contains the length - move it into rcx

        ret
